Ở trang 162, chương 3 trong sách có một định lý sau:

**Theorem 3.6.4.** The smallest positive number in the Z-module generated by
a and b is d = gcd(a; b)

Tóm tắt tư tưởng chứng minh trong sách: sử dụng phép phản chứng (Contradiction).
Giả sử d là số nguyên dương nhỏ nhất thuộc Z-module của a và b và d lớn hơn gcd(a,b). 
Ta đi tìm một số x nguyên dương nhỏ hơn d sao cho x vẫn thuộc Z-module. Từ đó suy ra giả thiết là sai và
điều phải chứng minh là đúng.

Rõ ràng ta thấy ngay bước quan trọng nhất trong chứng minh trên là đi tìm số x. Với một số d thì có rất
nhiều số x nhỏ hơn nó. Có thể là d-1, d-2, d/2, d - min(d, a)... Chọn số x như thế nào thì phù hợp? Trong
lời giải của sách, số x được chọn là số dư của phép chia a cho d. Cách chọn này dẫn tới một chứng minh đúng đắn.
Vấn đề là tại sao lại chọn được x như vậy? Có cách suy nghĩ tự nhiên nào dẫn tới chọn x như vậy hay không?

Một cách lý giải cho việc chọn x như vậy là vấn đề đang cần chứng minh nằm trong lĩnh vực lý thuyết số, và có liên quan
trực tiếp tới phép chia. Như vậy người làm toán lâu năm có thể có một cái "intuition" là chọn x làm số dư có thể 
ra kết quả tốt. 

Câu hỏi đặt ra là: liệu cái intuition đấy có thể được mô phỏng bằng AI được không? Ta có thể giả định là việc chọn 
số x cũng như tìm nước đi trên một bàn cờ. Thế thì các phương pháp Monte Carlo search tree đã áp dụng cho AlphaGo
có thể sẽ có tiềm năng áp dụng được. Cần nhắc lại rằng AlphaGo khi chọn nước đi thì không gian tìm kiếm của nó
là khổng lồ, gần như vô hạn. Việc chọn một số nguyên dương x nhỏ hơn một số nguyên dương d cũng như vậy, bởi trong toán
học có rất nhiều concept có thể diễn tả tính chất x < d.

Một cách chứng minh khác cho định lý trên là:

Trước tiên ta thử trường hợp là gcd(a, b) = 1. Nếu định lý gốc đúng thì nó cũng phải đúng trong trường hợp đơn giản này.
Ta đặt nó riêng thành một bổ đề nhỏ:

**Lemma 1**: If gcd(a, b) = 1 then there exists two number x, y in Z such that ax + by = 1.

Mặc dù chưa chứng minh được bổ đề này, ta có thể nhận ra ngay là nếu đã chứng minh được nó thì sẽ chứng minh được
định lý gốc. Cụ thể như sau: khi gcd(a, b) = d > 1 thì a = d*m và b = d*n trong đó gcd(m,n) = 1. Một số
bất kỳ thuộc Z-module của (a,b) có dạng

ax + by = d*m*x + d*n*y = d*(mx + ny)

Theo bổ đề 1, số nguyên dương nhỏ nhất mà mx + ny tạo ra sẽ bằng 1. Suy ra số nguyên dương nhỏ nhất mà ax + by tạo ra
sẽ bằng d.

Như vậy toàn bộ công việc còn lại là chứng minh bổ đề 1. Ta viết lại bổ đề 1 như sau:

gcd(a, b) = 1
ax + by = 1
<=> ax - 1 = by

Suy ra ax - 1 chia hết cho b. Suy ra ax = 1 (mod b). Vậy nếu ta tìm được một số x thỏa mãn phương trình đồng dư này thì xong.

Nghĩ thêm một chút ta thấy là không cần tìm x cụ thể mà chỉ cần chứng minh x tồn tại là được. Thật vậy, vì (a, b) = 1 nên nếu ta
nhân a với các số từ 1 tới b-1 ta sẽ được b-1 số dư khác nhau (mod b). Trong b-1 số dư đó chắc chắn có 1. Vậy tồn tại x sao cho
ax = 1 (mod b). Định lý được chứng minh.

Vậy trong 2 cách giải trên, cách nào tự nhiên hơn? Rất khó nói, có thể mỗi người có một quan điểm khác nhau. Cá nhân mình thích cách 
thứ 2 hơn. Mặc dù dài hơn và trình bày ra rắc rối hơn cách 1, mình cảm thấy kiểu suy nghĩ ở cách 2 có thể
được áp dụng cho những bài toán lớn hơn. Ở cách 2 có 2 lần suy nghĩ kiểu reduction: đầu tiên là xét trường hợp đặc biệt
để có bồ đề 1, sau đó lại đi từ "tìm x" sang "chứng minh là x tồn tại". Với các bài toán phức tạp hơn thì ở cách 1 việc tìm x không phải là đơn giản.
